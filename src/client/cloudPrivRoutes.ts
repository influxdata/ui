// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface OAuthClientConfig {
  clientID: string
  domain: string
  redirectURL: string
  state: string
}

export interface Error {
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'unprocessable entity'
    | 'empty value'
    | 'unavailable'
    | 'forbidden'
    | 'too many requests'
    | 'unauthorized'
    | 'method not allowed'
    | 'request too large'
    | 'unsupported media type'
  readonly message: string
  readonly op?: string
  readonly err?: string
}

export interface LimitEvents {
  links?: Links
  events?: LimitEvent[]
}

export interface Links {
  next?: Link
  self: Link
  prev?: Link
}

export type Link = string

export interface LimitEvent {
  orgID?: string
  type?:
    | 'limited_quota'
    | 'limited_write'
    | 'limited_query'
    | 'limited_cardinality'
  readonly timestamp?: string
}

export interface Limit {
  orgID?: string
  rate: {
    readKBs: number
    concurrentReadRequests: number
    writeKBs: number
    concurrentWriteRequests: number
    cardinality: number
  }
  bucket: {
    maxBuckets: number
    maxRetentionDuration: number
  }
  task: {
    maxTasks: number
  }
  dashboard: {
    maxDashboards: number
  }
  check: {
    maxChecks: number
  }
  notificationRule: {
    maxNotifications: number
    blockedNotificationRules?: string
  }
  notificationEndpoint: {
    blockedNotificationEndpoints?: string
  }
  features?: {
    allowDelete?: boolean
  }
}

export interface LimitStatuses {
  read: LimitStatus
  write: LimitStatus
  cardinality: LimitStatus
}

export interface LimitStatus {
  status: 'ok' | 'exceeded'
}

export interface OrgSettings {
  orgID?: string
  settings?: OrgSetting[]
}

export interface OrgSetting {
  key?: string
  value?: string
}

export interface OrganizationRequest {
  username?: string
  org?: string
  limit?: Limit
  retentionSeconds?: number
  bucket?: string
}

export interface InvalidRequestError {
  readonly code?: 'invalid'
  readonly message?: string
}

export interface UnauthorizedRequestError {
  readonly code?: 'unauthorized'
  readonly message?: string
}

export interface ForbiddenRequestError {
  readonly code?: 'forbidden'
  readonly message?: string
}

export interface OnboardingRequest {
  username: string
  password?: string
  org: string
  bucket: string
  retentionPeriodHrs?: number
  retentionPeriodSeconds?: number
  limit?: Limit
}

export interface OnboardingResponse {
  user?: {
    readonly id?: string
    oauthID?: string
    name: string
    status?: 'active' | 'inactive'
    readonly links?: {
      self?: string
    }
  }
  org?: {
    readonly links?: {
      self?: Link
      members?: Link
      owners?: Link
      labels?: Link
      secrets?: Link
      buckets?: Link
      tasks?: Link
      dashboards?: Link
    }
    readonly id?: string
    name: string
    description?: string
    readonly createdAt?: string
    readonly updatedAt?: string
    status?: 'active' | 'inactive'
  }
  bucket?: {
    readonly links?: {
      labels?: Link
      members?: Link
      org?: Link
      owners?: Link
      self?: Link
      write?: Link
    }
    readonly id?: string
    readonly type?: 'user' | 'system'
    name: string
    description?: string
    orgID?: string
    rp?: string
    schemaType?: 'implicit' | 'explicit'
    readonly createdAt?: string
    readonly updatedAt?: string
    retentionRules: Array<{
      type: 'expire'
      everySeconds: number
      shardGroupDurationSeconds?: number
    }>
    labels?: Array<{
      readonly id?: string
      readonly orgID?: string
      name?: string
      properties?: any
    }>
  }
  auth?: {
    status?: 'active' | 'inactive'
    description?: string
  } & {
    readonly createdAt?: string
    readonly updatedAt?: string
    orgID?: string
    permissions?: Array<{
      action: 'read' | 'write'
      resource: {
        type:
          | 'authorizations'
          | 'buckets'
          | 'dashboards'
          | 'orgs'
          | 'tasks'
          | 'telegrafs'
          | 'users'
          | 'variables'
          | 'secrets'
          | 'labels'
          | 'views'
          | 'documents'
          | 'notificationRules'
          | 'notificationEndpoints'
          | 'checks'
          | 'dbrp'
          | 'flows'
          | 'annotations'
          | 'functions'
        id?: string
        name?: string
        orgID?: string
        org?: string
      }
    }>
    readonly id?: string
    readonly token?: string
    readonly userID?: string
    readonly user?: string
    readonly org?: string
    readonly links?: {
      readonly self?: Link
      readonly user?: Link
    }
  }
}

interface RequestOptions {
  signal?: AbortSignal
}

export type RequestHandler = (
  url: string,
  query: string,
  init: RequestInit
) => {url: string; query: string; init: RequestInit}
export type ResponseHandler = (
  status: number,
  headers: Headers,
  data: any
) => {status: number; headers: Headers; data: any}

const RequestContext = function(
  requestHandler: RequestHandler,
  responseHandler: ResponseHandler
) {
  this.requestHandler = requestHandler
  this.responseHandler = responseHandler
}

RequestContext.prototype.request = async function(
  method: string,
  url: string,
  params: any = {},
  options: RequestOptions = {}
): Promise<any> {
  const requestHeaders = new Headers(params.headers)
  const contentType = requestHeaders.get('Content-Type') || ''

  if (params.auth) {
    const credentials = btoa(`${params.auth.username}:${params.auth.password}`)

    requestHeaders.append('Authorization', `Basic ${credentials}`)
  }

  const body =
    params.data && contentType.includes('json')
      ? JSON.stringify(params.data)
      : params.data

  const query = params.query ? `?${new URLSearchParams(params.query)}` : ''

  const {
    url: middlewareUrl,
    query: middlewareQuery,
    init,
  } = this.requestHandler(url, query, {
    method,
    body,
    credentials: 'same-origin',
    signal: options.signal,
    headers: requestHeaders,
  })

  const response = await fetch(`${middlewareUrl}${middlewareQuery}`, init)

  const {status, headers} = response
  const responseContentType = headers.get('Content-Type') || ''

  let data

  if (responseContentType.includes('json')) {
    data = await response.json()
  } else if (responseContentType.includes('octet-stream')) {
    data = await response.blob()
  } else {
    data = await response.text()
  }

  return this.responseHandler(status, headers, data)
}

RequestContext.prototype.setRequestHandler = function(
  requestHandler: RequestHandler
) {
  this.requestHandler = requestHandler
}

RequestContext.prototype.setResponseHandler = function(
  responseHandler: ResponseHandler
) {
  this.responseHandler = responseHandler
}

const rc = new RequestContext(
  (url, query, init) => {
    return {url, query, init}
  },
  (status, headers, data) => {
    return {status, headers, data}
  }
)
const request = rc.request.bind(rc)
const setRequestHandler = rc.setRequestHandler.bind(rc)
const setResponseHandler = rc.setResponseHandler.bind(rc)

export {request, setRequestHandler, setResponseHandler}

export interface GetOauthClientConfigParams {
  query?: {
    redirectTo?: string
  }
}

type GetOauthClientConfigResult =
  | GetOauthClientConfigOKResult
  | GetOauthClientConfigDefaultResult

interface GetOauthClientConfigOKResult {
  status: 200
  headers: Headers
  data: OAuthClientConfig
}

interface GetOauthClientConfigDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOauthClientConfig = (
  params: GetOauthClientConfigParams,
  options: RequestOptions = {}
): Promise<GetOauthClientConfigResult> =>
  request(
    'GET',
    '/api/v2private/oauth/clientConfig',
    params,
    options
  ) as Promise<GetOauthClientConfigResult>

export interface GetFlagsParams {}

type GetFlagsResult = GetFlagsOKResult | GetFlagsDefaultResult

interface GetFlagsOKResult {
  status: 200
  headers: Headers
  data: any
}

interface GetFlagsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getFlags = (
  params: GetFlagsParams,
  options: RequestOptions = {}
): Promise<GetFlagsResult> =>
  request('GET', '/api/v2private/flags', params, options) as Promise<
    GetFlagsResult
  >

export interface GetLimiteventsParams {
  query: {
    orgID: string
    start?: string
    stop?: string
    limit?: number
    offset?: number
  }
}

type GetLimiteventsResult = GetLimiteventsOKResult | GetLimiteventsDefaultResult

interface GetLimiteventsOKResult {
  status: 200
  headers: Headers
  data: LimitEvents
}

interface GetLimiteventsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getLimitevents = (
  params: GetLimiteventsParams,
  options: RequestOptions = {}
): Promise<GetLimiteventsResult> =>
  request('GET', '/api/v2private/limitevents', params, options) as Promise<
    GetLimiteventsResult
  >

export interface GetOrgsLimitsParams {
  orgID: string
}

type GetOrgsLimitsResult = GetOrgsLimitsOKResult | GetOrgsLimitsDefaultResult

interface GetOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: Limit
}

interface GetOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsLimits = (
  params: GetOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<GetOrgsLimitsResult> =>
  request(
    'GET',
    `/api/v2private/orgs/${params.orgID}/limits`,
    params,
    options
  ) as Promise<GetOrgsLimitsResult>

export interface PutOrgsLimitsParams {
  orgID: string

  data: Limit
}

type PutOrgsLimitsResult = PutOrgsLimitsOKResult | PutOrgsLimitsDefaultResult

interface PutOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: Limit
}

interface PutOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putOrgsLimits = (
  params: PutOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<PutOrgsLimitsResult> =>
  request(
    'PUT',
    `/api/v2private/orgs/${params.orgID}/limits`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutOrgsLimitsResult>

export interface GetOrgsLimitsStatusParams {
  orgID: string
}

type GetOrgsLimitsStatusResult =
  | GetOrgsLimitsStatusOKResult
  | GetOrgsLimitsStatusDefaultResult

interface GetOrgsLimitsStatusOKResult {
  status: 200
  headers: Headers
  data: LimitStatuses
}

interface GetOrgsLimitsStatusDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsLimitsStatus = (
  params: GetOrgsLimitsStatusParams,
  options: RequestOptions = {}
): Promise<GetOrgsLimitsStatusResult> =>
  request(
    'GET',
    `/api/v2private/orgs/${params.orgID}/limits/status`,
    params,
    options
  ) as Promise<GetOrgsLimitsStatusResult>

export interface GetOrgsSettingsParams {
  orgID: string
}

type GetOrgsSettingsResult =
  | GetOrgsSettingsOKResult
  | GetOrgsSettingsDefaultResult

interface GetOrgsSettingsOKResult {
  status: 200
  headers: Headers
  data: OrgSettings
}

interface GetOrgsSettingsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsSettings = (
  params: GetOrgsSettingsParams,
  options: RequestOptions = {}
): Promise<GetOrgsSettingsResult> =>
  request(
    'GET',
    `/api/v2private/orgs/${params.orgID}/settings`,
    params,
    options
  ) as Promise<GetOrgsSettingsResult>

export interface PutOrgsSettingsParams {
  orgID: string

  data: OrgSettings
}

type PutOrgsSettingsResult =
  | PutOrgsSettingsOKResult
  | PutOrgsSettingsDefaultResult

interface PutOrgsSettingsOKResult {
  status: 200
  headers: Headers
  data: OrgSettings
}

interface PutOrgsSettingsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putOrgsSettings = (
  params: PutOrgsSettingsParams,
  options: RequestOptions = {}
): Promise<PutOrgsSettingsResult> =>
  request(
    'PUT',
    `/api/v2private/orgs/${params.orgID}/settings`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutOrgsSettingsResult>

export interface PostTenantParams {
  data: OrganizationRequest
}

type PostTenantResult =
  | PostTenantCreatedResult
  | PostTenantBadRequestResult
  | PostTenantUnauthorizedResult
  | PostTenantForbiddenResult
  | PostTenantDefaultResult

interface PostTenantCreatedResult {
  status: 201
  headers: Headers
  data: {
    orgID?: string
    userID?: string
  }
}

interface PostTenantBadRequestResult {
  status: 400
  headers: Headers
  data: InvalidRequestError
}

interface PostTenantUnauthorizedResult {
  status: 401
  headers: Headers
  data: UnauthorizedRequestError
}

interface PostTenantForbiddenResult {
  status: 403
  headers: Headers
  data: ForbiddenRequestError
}

interface PostTenantDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postTenant = (
  params: PostTenantParams,
  options: RequestOptions = {}
): Promise<PostTenantResult> =>
  request(
    'POST',
    '/api/v2private/tenants',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostTenantResult>

export interface PostSetupUserParams {
  data: OnboardingRequest
}

type PostSetupUserResult =
  | PostSetupUserCreatedResult
  | PostSetupUserDefaultResult

interface PostSetupUserCreatedResult {
  status: 201
  headers: Headers
  data: OnboardingResponse
}

interface PostSetupUserDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postSetupUser = (
  params: PostSetupUserParams,
  options: RequestOptions = {}
): Promise<PostSetupUserResult> =>
  request(
    'POST',
    '/api/v2private/setup/user',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostSetupUserResult>

// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface TransportFlowList {
  flows?: TransportFlow[]
  nextPageToken?: string
}

export interface TransportFlow {
  orgID?: string
  id?: string
  name?: string
  spec?: {}
  createdAt?: string
  updatedAt?: string
}

export interface RuntimeError {
  error?: string
  code?: number
  message?: string
  details?: ProtobufAny[]
}

export interface ProtobufAny {
  type_url?: string
  value?: string
}

export interface TransportFlowCreateRequest {
  orgID?: string
  name?: string
  spec?: {}
}

export interface TransportFlowUpdateRequest {
  orgID?: string
  id?: string
  name?: string
  spec?: {}
}

interface RequestOptions {
  signal?: AbortSignal
}

export type RequestHandler = (
  url: string,
  query: string,
  init: RequestInit
) => {url: string; query: string; init: RequestInit}
export type ResponseHandler = (
  status: number,
  headers: Headers,
  data: any
) => {status: number; headers: Headers; data: any}

const RequestContext = function(
  requestHandler: RequestHandler,
  responseHandler: ResponseHandler
) {
  this.requestHandler = requestHandler
  this.responseHandler = responseHandler
}

RequestContext.prototype.request = async function(
  method: string,
  url: string,
  params: any = {},
  options: RequestOptions = {}
): Promise<any> {
  const requestHeaders = new Headers(params.headers)
  const contentType = requestHeaders.get('Content-Type') || ''

  if (params.auth) {
    const credentials = btoa(`${params.auth.username}:${params.auth.password}`)

    requestHeaders.append('Authorization', `Basic ${credentials}`)
  }

  const body =
    params.data && contentType.includes('json')
      ? JSON.stringify(params.data)
      : params.data

  const query = params.query ? `?${new URLSearchParams(params.query)}` : ''

  const {
    url: middlewareUrl,
    query: middlewareQuery,
    init,
  } = this.requestHandler(url, query, {
    method,
    body,
    credentials: 'same-origin',
    signal: options.signal,
    headers: requestHeaders,
  })

  const response = await fetch(`${middlewareUrl}${middlewareQuery}`, init)

  const {status, headers} = response
  const responseContentType = headers.get('Content-Type') || ''

  let data

  if (responseContentType.includes('json')) {
    data = await response.json()
  } else if (responseContentType.includes('octet-stream')) {
    data = await response.blob()
  } else if (responseContentType.includes('text')) {
    data = await response.text()
  }

  return this.responseHandler(status, headers, data)
}

RequestContext.prototype.setRequestHandler = function(
  requestHandler: RequestHandler
) {
  this.requestHandler = requestHandler
}

RequestContext.prototype.setResponseHandler = function(
  responseHandler: ResponseHandler
) {
  this.responseHandler = responseHandler
}

const rc = new RequestContext(
  (url, query, init) => {
    return {url, query, init}
  },
  (status, headers, data) => {
    return {status, headers, data}
  }
)
const request = rc.request.bind(rc)

export const setRequestHandler = rc.setRequestHandler.bind(rc)
export const setResponseHandler = rc.setResponseHandler.bind(rc)

export interface GetApiV2privateFlowsOrgsFlowsParams {
  orgID: string

  query?: {
    limit?: number
    pageToken?: string
  }
}

type GetApiV2privateFlowsOrgsFlowsResult =
  | GetApiV2privateFlowsOrgsFlowsOKResult
  | GetApiV2privateFlowsOrgsFlowsDefaultResult

interface GetApiV2privateFlowsOrgsFlowsOKResult {
  status: 200
  headers: Headers
  data: TransportFlowList
}

interface GetApiV2privateFlowsOrgsFlowsDefaultResult {
  status: 500
  headers: Headers
  data: RuntimeError
}

export const getApiV2privateFlowsOrgsFlows = (
  params: GetApiV2privateFlowsOrgsFlowsParams,
  options: RequestOptions = {}
): Promise<GetApiV2privateFlowsOrgsFlowsResult> =>
  request(
    'GET',
    `/api/v2private/flows/orgs/${params.orgID}/flows`,
    params,
    options
  ) as Promise<GetApiV2privateFlowsOrgsFlowsResult>

export interface PostApiV2privateFlowsOrgsFlowParams {
  orgID: string

  data: TransportFlowCreateRequest
}

type PostApiV2privateFlowsOrgsFlowResult =
  | PostApiV2privateFlowsOrgsFlowOKResult
  | PostApiV2privateFlowsOrgsFlowDefaultResult

interface PostApiV2privateFlowsOrgsFlowOKResult {
  status: 200
  headers: Headers
  data: TransportFlow
}

interface PostApiV2privateFlowsOrgsFlowDefaultResult {
  status: 500
  headers: Headers
  data: RuntimeError
}

export const postApiV2privateFlowsOrgsFlow = (
  params: PostApiV2privateFlowsOrgsFlowParams,
  options: RequestOptions = {}
): Promise<PostApiV2privateFlowsOrgsFlowResult> =>
  request(
    'POST',
    `/api/v2private/flows/orgs/${params.orgID}/flows`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostApiV2privateFlowsOrgsFlowResult>

export interface GetApiV2privateFlowsOrgsFlowParams {
  orgID: string
  id: string
}

type GetApiV2privateFlowsOrgsFlowResult =
  | GetApiV2privateFlowsOrgsFlowOKResult
  | GetApiV2privateFlowsOrgsFlowDefaultResult

interface GetApiV2privateFlowsOrgsFlowOKResult {
  status: 200
  headers: Headers
  data: TransportFlow
}

interface GetApiV2privateFlowsOrgsFlowDefaultResult {
  status: 500
  headers: Headers
  data: RuntimeError
}

export const getApiV2privateFlowsOrgsFlow = (
  params: GetApiV2privateFlowsOrgsFlowParams,
  options: RequestOptions = {}
): Promise<GetApiV2privateFlowsOrgsFlowResult> =>
  request(
    'GET',
    `/api/v2private/flows/orgs/${params.orgID}/flows/${params.id}`,
    params,
    options
  ) as Promise<GetApiV2privateFlowsOrgsFlowResult>

export interface PatchApiV2privateFlowsOrgsFlowParams {
  orgID: string
  id: string

  data: TransportFlowUpdateRequest
}

type PatchApiV2privateFlowsOrgsFlowResult =
  | PatchApiV2privateFlowsOrgsFlowOKResult
  | PatchApiV2privateFlowsOrgsFlowDefaultResult

interface PatchApiV2privateFlowsOrgsFlowOKResult {
  status: 200
  headers: Headers
  data: TransportFlow
}

interface PatchApiV2privateFlowsOrgsFlowDefaultResult {
  status: 500
  headers: Headers
  data: RuntimeError
}

export const patchApiV2privateFlowsOrgsFlow = (
  params: PatchApiV2privateFlowsOrgsFlowParams,
  options: RequestOptions = {}
): Promise<PatchApiV2privateFlowsOrgsFlowResult> =>
  request(
    'PATCH',
    `/api/v2private/flows/orgs/${params.orgID}/flows/${params.id}`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PatchApiV2privateFlowsOrgsFlowResult>

export interface DeleteApiV2privateFlowsOrgsFlowParams {
  orgID: string
  id: string
}

type DeleteApiV2privateFlowsOrgsFlowResult =
  | DeleteApiV2privateFlowsOrgsFlowOKResult
  | DeleteApiV2privateFlowsOrgsFlowDefaultResult

interface DeleteApiV2privateFlowsOrgsFlowOKResult {
  status: 200
  headers: Headers
  data: any
}

interface DeleteApiV2privateFlowsOrgsFlowDefaultResult {
  status: 500
  headers: Headers
  data: RuntimeError
}

export const deleteApiV2privateFlowsOrgsFlow = (
  params: DeleteApiV2privateFlowsOrgsFlowParams,
  options: RequestOptions = {}
): Promise<DeleteApiV2privateFlowsOrgsFlowResult> =>
  request(
    'DELETE',
    `/api/v2private/flows/orgs/${params.orgID}/flows/${params.id}`,
    params,
    options
  ) as Promise<DeleteApiV2privateFlowsOrgsFlowResult>
